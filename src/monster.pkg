/* File: monster.pkg */

/*
 * Purpose: Lua interface defitions for monsters.
 * To be processed by tolua to generate C source code.
 */

$#include "angband.h"

/** @typedef cptr
 * @note String
 */
typedef char* cptr;
/** @typedef errr
 * @note Number
 */
typedef int errr;
/** @typedef bool
 * @note Boolean
 */
typedef unsigned char bool;
/** @typedef byte
 * @note Number
 */
typedef unsigned char byte;
/** @typedef s16b
 * @note Number
 */
typedef signed short s16b;
/** @typedef u16b
 * @note Number
 */
typedef unsigned short u16b;
/** @typedef s32b
 * @note Number
 */
typedef signed int s32b;
/** @typedef u32b
 * @note Number
 */
typedef unsigned int u32b;

/* To make easy object creations */
$static monster_type lua_monster_forge;
/** @var  monster_forge;
 * @brief monster_type
 */
static monster_type lua_monster_forge @ monster_forge;

/** @name Monster status
 * @note Player POV
 * @{ */
/** @def MSTATUS_ENEMY */
#define MSTATUS_ENEMY           -2

/** @def MSTATUS_NEUTRAL_M */
#define MSTATUS_NEUTRAL_M       -1

/** @def MSTATUS_NEUTRAL */
#define MSTATUS_NEUTRAL         0

/** @def MSTATUS_NEUTRAL_P */
#define MSTATUS_NEUTRAL_P       1

/** @def MSTATUS_FRIEND */
#define MSTATUS_FRIEND          2

/** @def MSTATUS_PET */
#define MSTATUS_PET             3

/** @def MSTATUS_COMPANION */
#define MSTATUS_COMPANION       4
/** @} */

/** @name Race flags #1
 * @{ */
/** @def RF1_UNIQUE
 * @note Unique Monster 
 */
#define RF1_UNIQUE                      0x00000001      
/** @def RF1_QUESTOR
 * @note Quest Monster 
 */
#define RF1_QUESTOR                     0x00000002      
/** @def RF1_MALE
 * @note Male gender 
 */
#define RF1_MALE                        0x00000004      
/** @def RF1_FEMALE
 * @note Female gender 
 */
#define RF1_FEMALE                      0x00000008      
/** @def RF1_CHAR_CLEAR
 * @note Absorbs symbol 
 */
#define RF1_CHAR_CLEAR          0x00000010      
/** @def RF1_CHAR_MULTI
 * @note Changes symbol 
 */
#define RF1_CHAR_MULTI          0x00000020      
/** @def RF1_ATTR_CLEAR
 * @note Absorbs color 
 */
#define RF1_ATTR_CLEAR          0x00000040      
/** @def RF1_ATTR_MULTI
 * @note Changes color 
 */
#define RF1_ATTR_MULTI          0x00000080      
/** @def RF1_FORCE_DEPTH
 * @note Start at "correct" depth 
 */
#define RF1_FORCE_DEPTH         0x00000100      
/** @def RF1_FORCE_MAXHP
 * @note Start with max hitpoints 
 */
#define RF1_FORCE_MAXHP         0x00000200      
/** @def RF1_FORCE_SLEEP
 * @note Start out sleeping 
 */
#define RF1_FORCE_SLEEP         0x00000400      
/** @def RF1_FORCE_EXTRA
 * @note Start out something 
 */
#define RF1_FORCE_EXTRA         0x00000800      
/** @def RF1_FRIEND
 * @note Arrive with a friend 
 */
#define RF1_FRIEND              0x00001000      
/** @def RF1_FRIENDS
 * @note Arrive with some friends 
 */
#define RF1_FRIENDS             0x00002000      
/** @def RF1_ESCORT
 * @note Arrive with an escort 
 */
#define RF1_ESCORT              0x00004000      
/** @def RF1_ESCORTS
 * @note Arrive with some escorts 
 */
#define RF1_ESCORTS             0x00008000      
/** @def RF1_NEVER_BLOW
 * @note Never make physical blow 
 */
#define RF1_NEVER_BLOW          0x00010000      
/** @def RF1_NEVER_MOVE
 * @note Never make physical move 
 */
#define RF1_NEVER_MOVE          0x00020000      
/** @def RF1_RAND_25
 * @note Moves randomly (25%) 
 */
#define RF1_RAND_25             0x00040000      
/** @def RF1_RAND_50
 * @note Moves randomly (50%) 
 */
#define RF1_RAND_50             0x00080000      
/** @def RF1_ONLY_GOLD
 * @note Drop only gold 
 */
#define RF1_ONLY_GOLD           0x00100000      
/** @def RF1_ONLY_ITEM
 * @note Drop only items 
 */
#define RF1_ONLY_ITEM           0x00200000      
/** @def RF1_DROP_60
 * @note Drop an item/gold (60%) 
 */
#define RF1_DROP_60             0x00400000      
/** @def RF1_DROP_90
 * @note Drop an item/gold (90%) 
 */
#define RF1_DROP_90             0x00800000      
/** @def RF1_DROP_1D2
 * @note Drop 1d2 items/gold 
 */
#define RF1_DROP_1D2            0x01000000      
/** @def RF1_DROP_2D2
 * @note Drop 2d2 items/gold 
 */
#define RF1_DROP_2D2            0x02000000      
/** @def RF1_DROP_3D2
 * @note Drop 3d2 items/gold 
 */
#define RF1_DROP_3D2            0x04000000      
/** @def RF1_DROP_4D2
 * @note Drop 4d2 items/gold 
 */
#define RF1_DROP_4D2            0x08000000      
/** @def RF1_DROP_GOOD
 * @note Drop good items 
 */
#define RF1_DROP_GOOD           0x10000000      
/** @def RF1_DROP_GREAT
 * @note Drop great items 
 */
#define RF1_DROP_GREAT          0x20000000      
/** @def RF1_DROP_USEFUL
 * @note Drop "useful" items 
 */
#define RF1_DROP_USEFUL         0x40000000      
/** @def RF1_DROP_CHOSEN
 * @note Drop "chosen" items 
 */
#define RF1_DROP_CHOSEN         0x80000000      
/** @} */

/** @name Race flags #2
 * @note New monster race bit flags
 * @{ */
/** @def RF2_STUPID
 * @note Monster is stupid 
 */
#define RF2_STUPID                      0x00000001      
/** @def RF2_SMART
 * @note Monster is smart 
 */
#define RF2_SMART                       0x00000002      
/** @def RF2_CAN_SPEAK
 * @note TY: can speak 
 */
#define RF2_CAN_SPEAK            0x00000004  
/** @def RF2_REFLECTING
 * @note Reflects bolts 
 */
#define RF2_REFLECTING                  0x00000008      
/** @def RF2_INVISIBLE
 * @note Monster avoids vision 
 */
#define RF2_INVISIBLE           0x00000010      
/** @def RF2_COLD_BLOOD
 * @note Monster avoids infra 
 */
#define RF2_COLD_BLOOD          0x00000020      
/** @def RF2_EMPTY_MIND
 * @note Monster avoids telepathy 
 */
#define RF2_EMPTY_MIND          0x00000040      
/** @def RF2_WEIRD_MIND
 * @note Monster avoids telepathy? 
 */
#define RF2_WEIRD_MIND          0x00000080      
/** @def RF2_DEATH_ORB
 * @note Death Orb 
 */
#define RF2_DEATH_ORB           0x00000100      
/** @def RF2_REGENERATE
 * @note Monster regenerates 
 */
#define RF2_REGENERATE          0x00000200      
/** @def RF2_SHAPECHANGER
 * @note TY: shapechanger 
 */
#define RF2_SHAPECHANGER        0x00000400  
/** @def RF2_ATTR_ANY
 * @note TY: Attr_any 
 */
#define RF2_ATTR_ANY            0x00000800  
/** @def RF2_POWERFUL
 * @note Monster has strong breath 
 */
#define RF2_POWERFUL            0x00001000      
/** @def RF2_ELDRITCH_HORROR
 * @note Sanity-blasting horror    
 */
#define RF2_ELDRITCH_HORROR             0x00002000      
/** @def RF2_AURA_FIRE
 * @note Burns in melee 
 */
#define RF2_AURA_FIRE                   0x00004000      
/** @def RF2_AURA_ELEC
 * @note Shocks in melee 
 */
#define RF2_AURA_ELEC                   0x00008000      
/** @def RF2_OPEN_DOOR
 * @note Monster can open doors 
 */
#define RF2_OPEN_DOOR           0x00010000      
/** @def RF2_BASH_DOOR
 * @note Monster can bash doors 
 */
#define RF2_BASH_DOOR           0x00020000      
/** @def RF2_PASS_WALL
 * @note Monster can pass walls 
 */
#define RF2_PASS_WALL           0x00040000      
/** @def RF2_KILL_WALL
 * @note Monster can destroy walls 
 */
#define RF2_KILL_WALL           0x00080000      
/** @def RF2_MOVE_BODY
 * @note Monster can move monsters 
 */
#define RF2_MOVE_BODY           0x00100000      
/** @def RF2_KILL_BODY
 * @note Monster can kill monsters 
 */
#define RF2_KILL_BODY           0x00200000      
/** @def RF2_TAKE_ITEM
 * @note Monster can pick up items 
 */
#define RF2_TAKE_ITEM           0x00400000      
/** @def RF2_KILL_ITEM
 * @note Monster can crush items 
 */
#define RF2_KILL_ITEM           0x00800000      
/** @def RF2_BRAIN_1 */
#define RF2_BRAIN_1                     0x01000000

/** @def RF2_BRAIN_2 */
#define RF2_BRAIN_2                     0x02000000

/** @def RF2_BRAIN_3 */
#define RF2_BRAIN_3                     0x04000000

/** @def RF2_BRAIN_4 */
#define RF2_BRAIN_4                     0x08000000

/** @def RF2_BRAIN_5 */
#define RF2_BRAIN_5                     0x10000000

/** @def RF2_BRAIN_6 */
#define RF2_BRAIN_6                     0x20000000

/** @def RF2_BRAIN_7 */
#define RF2_BRAIN_7                     0x40000000

/** @def RF2_BRAIN_8 */
#define RF2_BRAIN_8                     0x80000000
/** @} */

/** @name Race flags #3
 * @note New monster race bit flags
 * @{ */
/** @def RF3_ORC
 * @note Orc 
 */
#define RF3_ORC                         0x00000001      
/** @def RF3_TROLL
 * @note Troll 
 */
#define RF3_TROLL                       0x00000002      
/** @def RF3_GIANT
 * @note Giant 
 */
#define RF3_GIANT                       0x00000004      
/** @def RF3_DRAGON
 * @note Dragon 
 */
#define RF3_DRAGON                      0x00000008      
/** @def RF3_DEMON
 * @note Demon 
 */
#define RF3_DEMON                       0x00000010      
/** @def RF3_UNDEAD
 * @note Undead 
 */
#define RF3_UNDEAD                      0x00000020      
/** @def RF3_EVIL
 * @note Evil 
 */
#define RF3_EVIL                        0x00000040      
/** @def RF3_ANIMAL
 * @note Animal 
 */
#define RF3_ANIMAL                      0x00000080      
/** @def RF3_THUNDERLORD
 * @note DG: Thunderlord 
 */
#define RF3_THUNDERLORD            0x00000100  
/** @def RF3_GOOD
 * @note Good 
 */
#define RF3_GOOD                        0x00000200      
/** @def RF3_AURA_COLD
 * @note Freezes in melee 
 */
#define RF3_AURA_COLD                        0x00000400      
/** @def RF3_NONLIVING
 * @note TY: Non-Living (?) 
 */
#define RF3_NONLIVING           0x00000800  
/** @def RF3_HURT_LITE
 * @note Hurt by lite 
 */
#define RF3_HURT_LITE           0x00001000      
/** @def RF3_HURT_ROCK
 * @note Hurt by rock remover 
 */
#define RF3_HURT_ROCK           0x00002000      
/** @def RF3_SUSCEP_FIRE
 * @note Hurt badly by fire 
 */
#define RF3_SUSCEP_FIRE           0x00004000      
/** @def RF3_SUSCEP_COLD
 * @note Hurt badly by cold 
 */
#define RF3_SUSCEP_COLD           0x00008000      
/** @def RF3_IM_ACID
 * @note Resist acid a lot 
 */
#define RF3_IM_ACID                     0x00010000      
/** @def RF3_IM_ELEC
 * @note Resist elec a lot 
 */
#define RF3_IM_ELEC                     0x00020000      
/** @def RF3_IM_FIRE
 * @note Resist fire a lot 
 */
#define RF3_IM_FIRE                     0x00040000      
/** @def RF3_IM_COLD
 * @note Resist cold a lot 
 */
#define RF3_IM_COLD                     0x00080000      
/** @def RF3_IM_POIS
 * @note Resist poison a lot 
 */
#define RF3_IM_POIS                     0x00100000      
/** @def RF3_RES_TELE
 * @note Resist teleportation 
 */
#define RF3_RES_TELE                    0x00200000      
/** @def RF3_RES_NETH
 * @note Resist nether a lot 
 */
#define RF3_RES_NETH            0x00400000      
/** @def RF3_RES_WATE
 * @note Resist water 
 */
#define RF3_RES_WATE            0x00800000      
/** @def RF3_RES_PLAS
 * @note Resist plasma 
 */
#define RF3_RES_PLAS            0x01000000      
/** @def RF3_RES_NEXU
 * @note Resist nexus 
 */
#define RF3_RES_NEXU            0x02000000      
/** @def RF3_RES_DISE
 * @note Resist disenchantment 
 */
#define RF3_RES_DISE            0x04000000      
/** @def RF3_UNIQUE_4
 * @note Is a "Nazgul" unique 
 */
#define RF3_UNIQUE_4                    0x08000000      
/** @def RF3_NO_FEAR
 * @note Cannot be scared 
 */
#define RF3_NO_FEAR                     0x10000000      
/** @def RF3_NO_STUN
 * @note Cannot be stunned 
 */
#define RF3_NO_STUN                     0x20000000      
/** @def RF3_NO_CONF
 * @note Cannot be confused 
 */
#define RF3_NO_CONF                     0x40000000      
/** @def RF3_NO_SLEEP
 * @note Cannot be slept 
 */
#define RF3_NO_SLEEP            0x80000000      
/** @} */

/** @name Race flags #4
 * @note New monster race bit flags
 * @{ */
/** @def RF4_SHRIEK
 * @note Shriek for help 
 */
#define RF4_SHRIEK                      0x00000001  
/** @def RF4_MULTIPLY
 * @note Monster reproduces 
 */
#define RF4_MULTIPLY                    0x00000002  
/** @def RF4_S_ANIMAL
 * @note Summon animals 
 */
#define RF4_S_ANIMAL                    0x00000004  
/** @def RF4_ROCKET
 * @note TY: Rocket 
 */
#define RF4_ROCKET                      0x00000008  
/** @def RF4_ARROW_1
 * @note Fire an arrow (light) 
 */
#define RF4_ARROW_1                     0x00000010  
/** @def RF4_ARROW_2
 * @note Fire an arrow (heavy) 
 */
#define RF4_ARROW_2                     0x00000020  
/** @def RF4_ARROW_3
 * @note Fire missiles (light) 
 */
#define RF4_ARROW_3                     0x00000040  
/** @def RF4_ARROW_4
 * @note Fire missiles (heavy) 
 */
#define RF4_ARROW_4                     0x00000080  
/** @def RF4_BR_ACID
 * @note Breathe Acid 
 */
#define RF4_BR_ACID                     0x00000100  
/** @def RF4_BR_ELEC
 * @note Breathe Elec 
 */
#define RF4_BR_ELEC                     0x00000200  
/** @def RF4_BR_FIRE
 * @note Breathe Fire 
 */
#define RF4_BR_FIRE                     0x00000400  
/** @def RF4_BR_COLD
 * @note Breathe Cold 
 */
#define RF4_BR_COLD                     0x00000800  
/** @def RF4_BR_POIS
 * @note Breathe Poison 
 */
#define RF4_BR_POIS                     0x00001000  
/** @def RF4_BR_NETH
 * @note Breathe Nether 
 */
#define RF4_BR_NETH                     0x00002000  
/** @def RF4_BR_LITE
 * @note Breathe Lite 
 */
#define RF4_BR_LITE                     0x00004000  
/** @def RF4_BR_DARK
 * @note Breathe Dark 
 */
#define RF4_BR_DARK                     0x00008000  
/** @def RF4_BR_CONF
 * @note Breathe Confusion 
 */
#define RF4_BR_CONF                     0x00010000  
/** @def RF4_BR_SOUN
 * @note Breathe Sound 
 */
#define RF4_BR_SOUN                     0x00020000  
/** @def RF4_BR_CHAO
 * @note Breathe Chaos 
 */
#define RF4_BR_CHAO                     0x00040000  
/** @def RF4_BR_DISE
 * @note Breathe Disenchant 
 */
#define RF4_BR_DISE                     0x00080000  
/** @def RF4_BR_NEXU
 * @note Breathe Nexus 
 */
#define RF4_BR_NEXU                     0x00100000  
/** @def RF4_BR_TIME
 * @note Breathe Time 
 */
#define RF4_BR_TIME                     0x00200000  
/** @def RF4_BR_INER
 * @note Breathe Inertia 
 */
#define RF4_BR_INER                     0x00400000  
/** @def RF4_BR_GRAV
 * @note Breathe Gravity 
 */
#define RF4_BR_GRAV                     0x00800000  
/** @def RF4_BR_SHAR
 * @note Breathe Shards 
 */
#define RF4_BR_SHAR                     0x01000000  
/** @def RF4_BR_PLAS
 * @note Breathe Plasma 
 */
#define RF4_BR_PLAS                     0x02000000  
/** @def RF4_BR_WALL
 * @note Breathe Force 
 */
#define RF4_BR_WALL                     0x04000000  
/** @def RF4_BR_MANA
 * @note Breathe Mana 
 */
#define RF4_BR_MANA                     0x08000000  
/** @def RF4_BA_NUKE
 * @note TY: Nuke Ball 
 */
#define RF4_BA_NUKE                     0x10000000  
/** @def RF4_BR_NUKE
 * @note TY: Toxic Breath 
 */
#define RF4_BR_NUKE                     0x20000000  
/** @def RF4_BA_CHAO
 * @note Chaos Ball 
 */
#define RF4_BA_CHAO                     0x40000000  
/** @def RF4_BR_DISI
 * @note Breathe Disintegration 
 */
#define RF4_BR_DISI                     0x80000000  
/** @} */

/** @name Race flags #5
 * @note New monster race bit flags
 * @{ */
/** @def RF5_BA_ACID
 * @note Acid Ball 
 */
#define RF5_BA_ACID                     0x00000001      
/** @def RF5_BA_ELEC
 * @note Elec Ball 
 */
#define RF5_BA_ELEC                     0x00000002      
/** @def RF5_BA_FIRE
 * @note Fire Ball 
 */
#define RF5_BA_FIRE                     0x00000004      
/** @def RF5_BA_COLD
 * @note Cold Ball 
 */
#define RF5_BA_COLD                     0x00000008      
/** @def RF5_BA_POIS
 * @note Poison Ball 
 */
#define RF5_BA_POIS                     0x00000010      
/** @def RF5_BA_NETH
 * @note Nether Ball 
 */
#define RF5_BA_NETH                     0x00000020      
/** @def RF5_BA_WATE
 * @note Water Ball 
 */
#define RF5_BA_WATE                     0x00000040      
/** @def RF5_BA_MANA
 * @note Mana Storm 
 */
#define RF5_BA_MANA                     0x00000080      
/** @def RF5_BA_DARK
 * @note Darkness Storm 
 */
#define RF5_BA_DARK                     0x00000100      
/** @def RF5_DRAIN_MANA
 * @note Drain Mana 
 */
#define RF5_DRAIN_MANA          0x00000200      
/** @def RF5_MIND_BLAST
 * @note Blast Mind 
 */
#define RF5_MIND_BLAST          0x00000400      
/** @def RF5_BRAIN_SMASH
 * @note Smash Brain 
 */
#define RF5_BRAIN_SMASH         0x00000800      
/** @def RF5_CAUSE_1
 * @note Cause Light Wound 
 */
#define RF5_CAUSE_1                     0x00001000      
/** @def RF5_CAUSE_2
 * @note Cause Serious Wound 
 */
#define RF5_CAUSE_2                     0x00002000      
/** @def RF5_CAUSE_3
 * @note Cause Critical Wound 
 */
#define RF5_CAUSE_3                     0x00004000      
/** @def RF5_CAUSE_4
 * @note Cause Mortal Wound 
 */
#define RF5_CAUSE_4                     0x00008000      
/** @def RF5_BO_ACID
 * @note Acid Bolt 
 */
#define RF5_BO_ACID                     0x00010000      
/** @def RF5_BO_ELEC
 * @note Elec Bolt (unused) 
 */
#define RF5_BO_ELEC                     0x00020000      
/** @def RF5_BO_FIRE
 * @note Fire Bolt 
 */
#define RF5_BO_FIRE                     0x00040000      
/** @def RF5_BO_COLD
 * @note Cold Bolt 
 */
#define RF5_BO_COLD                     0x00080000      
/** @def RF5_BO_POIS
 * @note Poison Bolt (unused) 
 */
#define RF5_BO_POIS                     0x00100000      
/** @def RF5_BO_NETH
 * @note Nether Bolt 
 */
#define RF5_BO_NETH                     0x00200000      
/** @def RF5_BO_WATE
 * @note Water Bolt 
 */
#define RF5_BO_WATE                     0x00400000      
/** @def RF5_BO_MANA
 * @note Mana Bolt 
 */
#define RF5_BO_MANA                     0x00800000      
/** @def RF5_BO_PLAS
 * @note Plasma Bolt 
 */
#define RF5_BO_PLAS                     0x01000000      
/** @def RF5_BO_ICEE
 * @note Ice Bolt 
 */
#define RF5_BO_ICEE                     0x02000000      
/** @def RF5_MISSILE
 * @note Magic Missile 
 */
#define RF5_MISSILE                     0x04000000      
/** @def RF5_SCARE
 * @note Frighten Player 
 */
#define RF5_SCARE                       0x08000000      
/** @def RF5_BLIND
 * @note Blind Player 
 */
#define RF5_BLIND                       0x10000000      
/** @def RF5_CONF
 * @note Confuse Player 
 */
#define RF5_CONF                        0x20000000      
/** @def RF5_SLOW
 * @note Slow Player 
 */
#define RF5_SLOW                        0x40000000      
/** @def RF5_HOLD
 * @note Paralyze Player 
 */
#define RF5_HOLD                        0x80000000      
/** @} */

/** @name Race flags #6
 * @note New monster race bit flags
 * @{ */
/** @def RF6_HASTE
 * @note Speed self 
 */
#define RF6_HASTE                       0x00000001      
/** @def RF6_HAND_DOOM
 * @note Hand of Doom 
 */
#define RF6_HAND_DOOM                   0x00000002      
/** @def RF6_HEAL
 * @note Heal self 
 */
#define RF6_HEAL                        0x00000004      
/** @def RF6_S_ANIMALS
 * @note Summon animals 
 */
#define RF6_S_ANIMALS                   0x00000008      
/** @def RF6_BLINK
 * @note Teleport Short 
 */
#define RF6_BLINK                       0x00000010      
/** @def RF6_TPORT
 * @note Teleport Long 
 */
#define RF6_TPORT                       0x00000020      
/** @def RF6_TELE_TO
 * @note Move player to monster 
 */
#define RF6_TELE_TO                     0x00000040      
/** @def RF6_TELE_AWAY
 * @note Move player far away 
 */
#define RF6_TELE_AWAY                   0x00000080      
/** @def RF6_TELE_LEVEL
 * @note Move player vertically 
 */
#define RF6_TELE_LEVEL                  0x00000100      
/** @def RF6_DARKNESS
 * @note Create Darkness 
 */
#define RF6_DARKNESS                    0x00000200      
/** @def RF6_TRAPS
 * @note Create Traps 
 */
#define RF6_TRAPS                       0x00000400      
/** @def RF6_FORGET
 * @note Cause amnesia 
 */
#define RF6_FORGET                      0x00000800      
/** @def RF6_RAISE_DEAD
 * @note Raise Dead 
 */
#define RF6_RAISE_DEAD                  0x00001000      
/** @def RF6_S_BUG
 * @note Summon Software bug 
 */
#define RF6_S_BUG                       0x00002000      
/** @def RF6_S_RNG
 * @note Summon RNG 
 */
#define RF6_S_RNG                       0x00004000      
/** @def RF6_S_THUNDERLORD
 * @note Summon Thunderlords 
 */
#define RF6_S_THUNDERLORD               0x00008000      
/** @def RF6_S_KIN
 * @note Summon "kin" 
 */
#define RF6_S_KIN                       0x00010000      
/** @def RF6_S_HI_DEMON
 * @note Summon greater demons! 
 */
#define RF6_S_HI_DEMON                  0x00020000      
/** @def RF6_S_MONSTER
 * @note Summon Monster 
 */
#define RF6_S_MONSTER                   0x00040000      
/** @def RF6_S_MONSTERS
 * @note Summon Monsters 
 */
#define RF6_S_MONSTERS                  0x00080000      
/** @def RF6_S_ANT
 * @note Summon Ants 
 */
#define RF6_S_ANT                       0x00100000      
/** @def RF6_S_SPIDER
 * @note Summon Spiders 
 */
#define RF6_S_SPIDER                    0x00200000      
/** @def RF6_S_HOUND
 * @note Summon Hounds 
 */
#define RF6_S_HOUND                     0x00400000      
/** @def RF6_S_HYDRA
 * @note Summon Hydras 
 */
#define RF6_S_HYDRA                     0x00800000      
/** @def RF6_S_ANGEL
 * @note Summon Angel 
 */
#define RF6_S_ANGEL                     0x01000000      
/** @def RF6_S_DEMON
 * @note Summon Demon 
 */
#define RF6_S_DEMON                     0x02000000      
/** @def RF6_S_UNDEAD
 * @note Summon Undead 
 */
#define RF6_S_UNDEAD            0x04000000      
/** @def RF6_S_DRAGON
 * @note Summon Dragon 
 */
#define RF6_S_DRAGON            0x08000000      
/** @def RF6_S_HI_UNDEAD
 * @note Summon Greater Undead 
 */
#define RF6_S_HI_UNDEAD         0x10000000      
/** @def RF6_S_HI_DRAGON
 * @note Summon Ancient Dragon 
 */
#define RF6_S_HI_DRAGON         0x20000000      
/** @def RF6_S_WRAITH
 * @note Summon Unique Wraith 
 */
#define RF6_S_WRAITH            0x40000000      
/** @def RF6_S_UNIQUE
 * @note Summon Unique Monster 
 */
#define RF6_S_UNIQUE            0x80000000      
/** @} */

/** @name Race flags #7
 * @note New monster race bit flags
 * @{ */
/** @def RF7_AQUATIC
 * @note Aquatic monster 
 */
#define RF7_AQUATIC             0x00000001  
/** @def RF7_CAN_SWIM
 * @note Monster can swim 
 */
#define RF7_CAN_SWIM            0x00000002  
/** @def RF7_CAN_FLY
 * @note Monster can fly 
 */
#define RF7_CAN_FLY             0x00000004  
/** @def RF7_FRIENDLY
 * @note Monster is friendly 
 */
#define RF7_FRIENDLY            0x00000008  
/** @def RF7_PET
 * @note Monster is a pet 
 */
#define RF7_PET                 0x00000010  
/** @def RF7_MORTAL
 * @note Monster is a mortal being 
 */
#define RF7_MORTAL              0x00000020  
/** @def RF7_SPIDER
 * @note Monster is a spider (can pass webs) 
 */
#define RF7_SPIDER              0x00000040  
/** @def RF7_NAZGUL
 * @note Monster is a Nazgul 
 */
#define RF7_NAZGUL              0x00000080  
/** @def RF7_DG_CURSE
 * @note If killed the monster grant a DG Curse to the player 
 */
#define RF7_DG_CURSE            0x00000100  
/** @def RF7_POSSESSOR
 * @note Is it a dreaded possessor monster ? 
 */
#define RF7_POSSESSOR           0x00000200  
/** @def RF7_NO_DEATH
 * @note Cannot be killed 
 */
#define RF7_NO_DEATH            0x00000400  
/** @def RF7_NO_TARGET
 * @note Cannot be targeted 
 */
#define RF7_NO_TARGET           0x00000800  
/** @def RF7_AI_ANNOY
 * @note Try to tease the player 
 */
#define RF7_AI_ANNOY            0x00001000  
/** @def RF7_AI_SPECIAL
 * @note For quests 
 */
#define RF7_AI_SPECIAL          0x00002000  
/** @def RF7_NO_THEFT
 * @note Monster is immune to theft 
 */
#define RF7_NO_THEFT			0x00040000  
/** @def RF7_SPIRIT
 * @note This is a Spirit, coming from the Void 
 */
#define RF7_SPIRIT		0x00080000  
/** @def RF7_IM_MELEE
 * @note IM melee 
 */
#define RF7_IM_MELEE            0x00100000  
/** @} */

/** @name Race flags #8
 * @note New monster race bit flags
 * @{ */
/** @def RF8_DUNGEON */
#define RF8_DUNGEON             0x00000001

/** @def RF8_WILD_TOWN */
#define RF8_WILD_TOWN           0x00000002

/** @def RF8_XXX8X02 */
#define RF8_XXX8X02             0x00000004

/** @def RF8_WILD_SHORE */
#define RF8_WILD_SHORE          0x00000008

/** @def RF8_WILD_OCEAN */
#define RF8_WILD_OCEAN          0x00000010

/** @def RF8_WILD_WASTE */
#define RF8_WILD_WASTE          0x00000020

/** @def RF8_WILD_WOOD */
#define RF8_WILD_WOOD           0x00000040

/** @def RF8_WILD_VOLCANO */
#define RF8_WILD_VOLCANO        0x00000080

/** @def RF8_XXX8X08 */
#define RF8_XXX8X08             0x00000100

/** @def RF8_WILD_MOUNTAIN */
#define RF8_WILD_MOUNTAIN       0x00000200

/** @def RF8_WILD_GRASS */
#define RF8_WILD_GRASS          0x00000400

/********* FREE *********/
/** @def RF8_CTHANGBAND */
#define RF8_CTHANGBAND          0x00001000

/********* FREE *********/
/** @def RF8_ZANGBAND */
#define RF8_ZANGBAND            0x00004000

/** @def RF8_JOKEANGBAND */
#define RF8_JOKEANGBAND         0x00008000

/** @def RF8_ANGBAND */
#define RF8_ANGBAND             0x00010000


/** @def RF8_WILD_TOO */
#define RF8_WILD_TOO            0x80000000
/** @} */

/** @name Race flags #9
 * @note New monster race bit flags
 * @{ */
/** @def RF9_DROP_CORPSE */
#define RF9_DROP_CORPSE         0x00000001

/** @def RF9_DROP_SKELETON */
#define RF9_DROP_SKELETON       0x00000002

/** @def RF9_HAS_LITE
 * @note Carries a lite 
 */
#define RF9_HAS_LITE            0x00000004      
/** @def RF9_MIMIC
 * @note *REALLY* looks like an object ... only nastier 
 */
#define RF9_MIMIC               0x00000008      
/** @def RF9_HAS_EGG
 * @note Can be monster's eggs 
 */
#define RF9_HAS_EGG             0x00000010      
/** @def RF9_IMPRESED
 * @note The monster can follow you on each level until he dies 
 */
#define RF9_IMPRESED            0x00000020      
/** @def RF9_SUSCEP_ACID
 * @note Susceptible to acid 
 */
#define RF9_SUSCEP_ACID         0x00000040      
/** @def RF9_SUSCEP_ELEC
 * @note Susceptible to lightning 
 */
#define RF9_SUSCEP_ELEC         0x00000080      
/** @def RF9_SUSCEP_POIS
 * @note Susceptible to poison 
 */
#define RF9_SUSCEP_POIS         0x00000100      
/** @def RF9_KILL_TREES
 * @note Monster can eat trees 
 */
#define RF9_KILL_TREES          0x00000200      
/** @def RF9_WYRM_PROTECT
 * @note The monster is protected by great wyrms of power: They'll be summoned if it's killed 
 */
#define RF9_WYRM_PROTECT        0x00000400      
/** @def RF9_DOPPLEGANGER
 * @note The monster looks like you 
 */
#define RF9_DOPPLEGANGER        0x00000800      
/** @def RF9_ONLY_DEPTH
 * @note The monster can only be generated at the GIVEN depth 
 */
#define RF9_ONLY_DEPTH          0x00001000      
/** @def RF9_SPECIAL_GENE
 * @note The monster can only be generated in special conditions like quests, special dungeons, ... 
 */
#define RF9_SPECIAL_GENE        0x00002000      
/** @def RF9_NEVER_GENE
 * @note The monster cannot be normaly generated 
 */
#define RF9_NEVER_GENE          0x00004000      
/** @} */

/** @name Monster flags
 * @{ */
/** @def MFLAG_VIEW
 * @note Monster is in line of sight 
 */
#define MFLAG_VIEW      0x00000001    
/** @def MFLAG_QUEST
 * @note Monster is subject to a quest 
 */
#define MFLAG_QUEST     0x00000002    
/** @def MFLAG_PARTIAL
 * @note Monster is a partial summon 
 */
#define MFLAG_PARTIAL   0x00000004    
/** @def MFLAG_CONTROL
 * @note Monster is controlled 
 */
#define MFLAG_CONTROL   0x00000008    
/** @def MFLAG_BORN
 * @note Monster is still being born 
 */
#define MFLAG_BORN      0x00000010    
/** @def MFLAG_NICE
 * @note Monster is still being nice 
 */
#define MFLAG_NICE      0x00000020    
/** @def MFLAG_SHOW
 * @note Monster is recently memorized 
 */
#define MFLAG_SHOW      0x00000040    
/** @def MFLAG_MARK
 * @note Monster is currently memorized 
 */
#define MFLAG_MARK      0x00000080    
/** @def MFLAG_NO_DROP
 * @note Monster wont drop obj/corpse 
 */
#define MFLAG_NO_DROP   0x00000100    
/** @def MFLAG_QUEST2
 * @note Monster is subject to a quest 
 */
#define MFLAG_QUEST2    0x00000200    
/** @} */

/** @struct monster_blow
 * @brief Monster blows (attacks)
 */
struct monster_blow
{
	/** @structvar method
	 * @brief Number
	 */
	byte method;
	/** @structvar effect
	 * @brief Number
	 */
	byte effect;
	/** @structvar d_dice
	 * @brief Number
	 */
	byte d_dice;
	/** @structvar d_side
	 * @brief Number
	 */
	byte d_side;
};

/** @struct monster_race
 * @brief Monster race
 */
struct monster_race
{
	/** @structvar name
	 * @brief Number
	 * @note Name (offset) 
	 */
	u32b name;
	/** @structvar text
	 * @brief Number
	 * @note Text (offset) 
	 */
	u32b text;

	/** @structvar hdice
	 * @brief Number
	 * @note Creatures hit dice count 
	 */
	byte hdice;
	/** @structvar hside
	 * @brief Number
	 * @note Creatures hit dice sides 
	 */
	byte hside;

	/** @structvar ac
	 * @brief Number
	 * @note Armour Class 
	 */
	s16b ac;

	/** @structvar sleep
	 * @brief Number
	 * @note Inactive counter (base) 
	 */
	s16b sleep;
	/** @structvar aaf
	 * @brief Number
	 * @note Area affect radius (1-100) 
	 */
	byte aaf;
	/** @structvar speed
	 * @brief Number
	 * @note Speed (normally 110) 
	 */
	byte speed;

	/** @structvar mexp
	 * @brief Number
	 * @note Exp value for kill 
	 */
	s32b mexp;

	/** @structvar weight
	 * @brief Number
	 * @note Weight of the monster 
	 */
	s32b weight;

	/** @structvar freq_inate
	 * @brief Number
	 * @note Inate spell frequency 
	 */
	byte freq_inate;
	/** @structvar freq_spell
	 * @brief Number
	 * @note Other spell frequency 
	 */
	byte freq_spell;

	/** @structvar flags1
	 * @brief Number
	 * @note Flags 1 (general) 
	 */
	u32b flags1;
	/** @structvar flags2
	 * @brief Number
	 * @note Flags 2 (abilities) 
	 */
	u32b flags2;
	/** @structvar flags3
	 * @brief Number
	 * @note Flags 3 (race/resist) 
	 */
	u32b flags3;
	/** @structvar flags4
	 * @brief Number
	 * @note Flags 4 (inate/breath) 
	 */
	u32b flags4;
	/** @structvar flags5
	 * @brief Number
	 * @note Flags 5 (normal spells) 
	 */
	u32b flags5;
	/** @structvar flags6
	 * @brief Number
	 * @note Flags 6 (special spells) 
	 */
	u32b flags6;
	/** @structvar flags7
	 * @brief Number
	 * @note Flags 7 (movement related abilities) 
	 */
	u32b flags7;
	/** @structvar flags8
	 * @brief Number
	 * @note Flags 8 (wilderness info) 
	 */
	u32b flags8;
	/** @structvar flags9
	 * @brief Number
	 * @note Flags 9 (drops info) 
	 */
	u32b flags9;

	/** @structvar blow[4]
	 * @brief magic_power
	 * @note Up to four blows per round 
	 */
	monster_blow blow[4];

	/** @structvar body_parts[BODY_MAX]
	 * @brief Number
	 * @note To help to decide what to use when body changing 
	 */
	byte body_parts[BODY_MAX];

	/** @structvar level
	 * @brief Number
	 * @note Level of creature 
	 */
	byte level;
	/** @structvar rarity
	 * @brief Number
	 * @note Rarity of creature 
	 */
	byte rarity;


	/** @structvar d_attr
	 * @brief Number
	 * @note Default monster attribute 
	 */
	byte d_attr;
	/** @structvar d_char
	 * @brief String
	 * @note Default monster character 
	 */
	char d_char;


	/** @structvar x_attr
	 * @brief Number
	 * @note Desired monster attribute 
	 */
	byte x_attr;
	/** @structvar x_char
	 * @brief String
	 * @note Desired monster character 
	 */
	char x_char;


	/** @structvar max_num
	 * @brief Number
	 * @note Maximum population allowed per level 
	 */
	s16b max_num;

	/** @structvar cur_num
	 * @brief Number
	 * @note Monster population on current level 
	 */
	byte cur_num;


	/** @structvar r_sights
	 * @brief Number
	 * @note Count sightings of this monster 
	 */
	s16b r_sights;
	/** @structvar r_deaths
	 * @brief Number
	 * @note Count deaths from this monster 
	 */
	s16b r_deaths;

	/** @structvar r_pkills
	 * @brief Number
	 * @note Count monsters killed in this life 
	 */
	s16b r_pkills;
	/** @structvar r_tkills
	 * @brief Number
	 * @note Count monsters killed in all lives 
	 */
	s16b r_tkills;

	/** @structvar r_wake
	 * @brief Number
	 * @note Number of times woken up (?) 
	 */
	byte r_wake;
	/** @structvar r_ignore
	 * @brief Number
	 * @note Number of times ignored (?) 
	 */
	byte r_ignore;

	/** @structvar r_xtra1
	 * @brief Number
	 * @note Something (unused) 
	 */
	byte r_xtra1;
	/** @structvar r_xtra2
	 * @brief Number
	 * @note Something (unused) 
	 */
	byte r_xtra2;

	/** @structvar r_drop_gold
	 * @brief Number
	 * @note Max number of gold dropped at once 
	 */
	byte r_drop_gold;
	/** @structvar r_drop_item
	 * @brief Number
	 * @note Max number of item dropped at once 
	 */
	byte r_drop_item;

	/** @structvar r_cast_inate
	 * @brief Number
	 * @note Max number of inate spells seen 
	 */
	byte r_cast_inate;
	/** @structvar r_cast_spell
	 * @brief Number
	 * @note Max number of other spells seen 
	 */
	byte r_cast_spell;

	/** @structvar r_blows[4]
	 * @brief Number
	 * @note Number of times each blow type was seen 
	 */
	byte r_blows[4];

	/** @structvar r_flags1
	 * @brief Number
	 * @note Observed racial flags 
	 */
	u32b r_flags1;
	/** @structvar r_flags2
	 * @brief Number
	 * @note Observed racial flags 
	 */
	u32b r_flags2;
	/** @structvar r_flags3
	 * @brief Number
	 * @note Observed racial flags 
	 */
	u32b r_flags3;
	/** @structvar r_flags4
	 * @brief Number
	 * @note Observed racial flags 
	 */
	u32b r_flags4;
	/** @structvar r_flags5
	 * @brief Number
	 * @note Observed racial flags 
	 */
	u32b r_flags5;
	/** @structvar r_flags6
	 * @brief Number
	 * @note Observed racial flags 
	 */
	u32b r_flags6;
	/** @structvar r_flags7
	 * @brief Number
	 * @note Observed racial flags 
	 */
	u32b r_flags7;
	/** @structvar r_flags8
	 * @brief Number
	 * @note Observed racial flags 
	 */
	u32b r_flags8;
	/** @structvar r_flags9
	 * @brief Number
	 * @note Observed racial flags 
	 */
	u32b r_flags9;

	/** @structvar on_saved
	 * @brief Boolean
	 * @note Is the (unique) on a saved level ? 
	 */
	bool on_saved;

	/** @structvar total_visible
	 * @brief Number
	 * @note Amount of this race that are visible 
	 */
	byte total_visible;

	/** @structvar drops
	 * @brief obj_theme
	 * @note The drops type 
	 */
	obj_theme drops;
};

/** @struct monster_type
 * @brief Monster type
 */
struct monster_type
{
	/** @structvar r_idx
	 * @brief Number
	 * @note Monster race index 
	 */
	s16b r_idx;

	/** @structvar ego
	 * @brief Number
	 * @note Ego monster type 
	 */
	u16b ego;

	/** @structvar fy
	 * @brief Number
	 * @note Y location on map 
	 */
	byte fy;
	/** @structvar fx
	 * @brief Number
	 * @note X location on map 
	 */
	byte fx;

	/** @structvar hp
	 * @brief Number
	 * @note Current Hit points 
	 */
	s16b hp;
	/** @structvar maxhp
	 * @brief Number
	 * @note Max Hit points 
	 */
	s16b maxhp;

	/** @structvar blow[4]
	 * @brief magic_power
	 * @note Up to four blows per round 
	 */
	monster_blow blow[4];

	/** @structvar speed
	 * @brief Number
	 * @note Speed (normally 110) 
	 */
	byte speed;
	/** @structvar level
	 * @brief Number
	 * @note Level of creature 
	 */
	byte level;
	/** @structvar ac
	 * @brief Number
	 * @note Armour Class 
	 */
	s16b ac;
	/** @structvar exp
	 * @brief Number
	 * @note Experience 
	 */
	u32b exp;

	/** @structvar csleep
	 * @brief Number
	 * @note Inactive counter 
	 */
	s16b csleep;

	/** @structvar mspeed
	 * @brief Number
	 * @note Monster "speed" 
	 */
	byte mspeed;
	/** @structvar energy
	 * @brief Number
	 * @note Monster "energy" 
	 */
	byte energy;

	/** @structvar stunned
	 * @brief Number
	 * @note Monster is stunned 
	 */
	byte stunned;
	/** @structvar confused
	 * @brief Number
	 * @note Monster is confused 
	 */
	byte confused;
	/** @structvar monfear
	 * @brief Number
	 * @note Monster is afraid 
	 */
	byte monfear;

	/** @structvar bleeding
	 * @brief Number
	 * @note Monster is bleeding 
	 */
	s16b bleeding;
	/** @structvar poisoned
	 * @brief Number
	 * @note Monster is poisoned 
	 */
	s16b poisoned;

	/** @structvar cdis
	 * @brief Number
	 * @note Current dis from player 
	 */
	byte cdis;

	/** @structvar mflag
	 * @brief Number
	 * @note Extra monster flags 
	 */
	s32b mflag;

	/** @structvar ml
	 * @brief Boolean
	 * @note Monster is "visible" 
	 */
	bool ml;

	/** @structvar hold_o_idx
	 * @brief Number
	 * @note Object being held (if any) 
	 */
	s16b hold_o_idx;

	/** @structvar smart
	 * @brief Number
	 * @note Field for "smart_learn" 
	 */
	u32b smart;

	/** @structvar status
	 * @brief Number
	 * @note Status(friendly, pet, companion, ..) 
	 */
	s16b status;

	/** @structvar target
	 * @brief Number
	 * @note Monster target 
	 */
	s16b target;

	/** @structvar possessor
	 * @brief Number
	 * @note Is it under the control of a possessor ? 
	 */
	s16b possessor;
};

$static monster_type *lua_get_monster(int m_idx){return (&m_list[m_idx]);}
/** @fn monster(int m_idx);
 * @brief Return the monster with index "m_idx" in the monster list.\n
 * @param m_idx Number \n the index of the monster in the monster list
 * @brief Monster index
 * @return monster_type \n The monster.
 * @note (see file w_mnster.c)
 */
static monster_type *lua_get_monster @ monster(int m_idx);

/** @var m_list[max_m_idx]
 * @brief monster_type
 * @note List of monsters
 */
extern monster_type m_list[max_m_idx];

/** @fn race_info_idx(int r_idx, int ego)
 * @brief Get monster info and ego info for monster with monster index "r_idx"
 * and monster ego "ego".\n
 * @param r_idx Number \n the index of the race in the monster race array
 * @brief Race index
 * @param ego Number \n the index of the ego in the monster ego array
 * @brief Ego index
 * @return monster_race \n The monster race.
 * @note
 * If "ego" > 0, the ego information is applied to the monster information and
 * the new monster information is returned.
 * @note
 * For example, race_info_idx(141,7) will create a brown yeek (monster)
 * shaman (ego).
 * @note (see file monster2.c)
 */
extern monster_race* race_info_idx(int r_idx, int ego);

/** @fn delete_monster_idx(int i)
 * @brief Delete monster "i" from the monster array.\n
 * @param i Number \n the index of the monster in the monster list
 * @brief Monster index
 * @note (see file monster2.c)
 */
extern void delete_monster_idx(int i);

/** @fn m_pop(void)
 * @brief Get an empty slot in the monster list.
 * @return Number \n The index of an empty slot the monster list.
 * @note
 * If there are no empty slots, a slot will be reclaimed from a "dead"
 * monster. If all slots are full, 0 is returned, which means the function
 * has failed ("Too many monsters!").
 * @note (see file monster2.c)
 */
extern s16b m_pop(void);

/** @fn get_mon_num_prep(void)
 * @brief Apply a "monster restriction function" to the "monster allocation
 * table".
 * @return Number \n 0 (success) always.
 * @note
 * There are no parameters, but there are some other variables which will
 * need to be set. They are get_mon_num_hook and get_mon_num2_hook. They
 * are pointers to functions.
 * @note
 * For example, get_mon_num_hook = monster_volcano means when
 * get_mon_num_hook is called (*get_mon_num_hook)(index), the actual
 * function called is monster_volcano(index). This particular function
 * returns TRUE if the monster indicated by "index" has the
 * RF8_WILD_VOLCANO flag set.
 * @note
 * It is a good idea to store the old value of get_mon_num_hook before
 * setting a new one, and restoring it when your function is finished.
 * @note
 * Following is a list of functions which can be assigned to
 * get_mon_num_hook:\n
 * create_molds_hook\n
 * create_townpeople_hook\n
 * mon_hook_bounty\n
 * monster_dungeon\n
 * monster_grass\n
 * monster_mountain\n
 * monster_ocean\n
 * monster_quest\n
 * monster_shore\n
 * monster_town\n
 * monster_volcano\n
 * monster_waste\n
 * monster_wood\n
 * mutate_monster_okay\n
 * place_monster_okay\n
 * summon_specific_okay\n
 * vault_aux_animal\n
 * vault_aux_chapel\n
 * vault_aux_clone\n
 * vault_aux_demon\n
 * vault_aux_dragon\n
 * vault_aux_giant\n
 * vault_aux_jelly\n
 * vault_aux_kennel\n
 * vault_aux_orc\n
 * vault_aux_symbol\n
 * vault_aux_treasure\n
 * vault_aux_troll\n
 * vault_aux_undead
 * @note
 * Or you can write your own. The function must take an integer (index)
 * as a parameter and return boolean (TRUE if the monster is selected,
 * or FALSE if it is not).
 * @note (see file monster2.c)
 */
extern errr get_mon_num_prep(void);

/** @fn get_mon_num(int level)
 * @brief For the given level "level", return the index of an appropriate
 * monster race.\n
 * @param level Number \n a dungeon level (which is adjusted before
 * it is used).
 * @brief Dungeon level
 * @return Number \n The index of a monster race in the monster race array.
 * @note
 * This function uses the "prob2" field of the "monster allocation table",
 * and various local information, to calculate the "prob3" field of the
 * same table, which is then used to choose an "appropriate" monster, in
 * a relatively efficient manner.
 * @note
 * Note that "town" monsters will *only* be created in the town, and
 * "normal" monsters will *never* be created in the town, unless the
 * "level" is "modified", for example, by polymorph or summoning.
 * @note
 * There is a small chance (1/50) of "boosting" the given depth by
 * a small amount (up to four levels), except in the town.
 * @note
 * It is (slightly) more likely to acquire a monster of the given level
 * than one of a lower level.  This is done by choosing several monsters
 * appropriate to the given level and keeping the "hardest" one.
 * @note
 * Note that if no monsters are "appropriate", then this function will
 * fail, and return zero, but this should *almost* never happen.
 * @note (see file monster2.c)
 */
extern s16b get_mon_num(int level);

$static char *lua_monster_desc(monster_type *m_ptr, int mode){static char buf[200]; monster_desc(buf, m_ptr, mode); return buf;}
/** @fn monster_desc(monster_type *m_ptr, int mode);
 * @brief Return a monster description for monster "monster_type" using flag
 * "mode".\n
 * @param *m_ptr monster_type \n the monster
 * @brief Monster
 * @param mode Number \n description mode (see below)
 * @brief Description mode
 * @return String \n The description of the monster.
 * @note
 * We can correctly describe monsters based on their visibility.\n
 * We can force all monsters to be treated as visible or invisible.\n
 * We can build nominatives, objectives, possessives, or reflexives.\n
 * We can selectively pronominalize hidden, visible, or all monsters.\n
 * We can use definite or indefinite descriptions for hidden monsters.\n
 * We can use definite or indefinite descriptions for visible monsters.
 * @note
 * Pronominalization involves the gender whenever possible and allowed,
 * so that by cleverly requesting pronominalization / visibility, you
 * can get messages like "You hit someone.  She screams in agony!".
 * @note
 * Reflexives are acquired by requesting Objective plus Possessive.
 * @note
 * If no m_ptr arg is given (?), the monster is assumed to be hidden,
 * unless the "Assume Visible" mode is requested.
 * @note
 * If no r_ptr arg is given, it is extracted from m_ptr and r_info
 * If neither m_ptr nor r_ptr is given, the monster is assumed to
 * be neuter, singular, and hidden (unless "Assume Visible" is set),
 * in which case you may be in trouble... :-)
 * @note
 * I am assuming that no monster name is more than 70 characters long,
 * so that "char desc[80];" is sufficiently large for any result.
 * @note
 * Mode Flags:\n
 *   0x01 --> Objective (or Reflexive)\n
 *   0x02 --> Possessive (or Reflexive)\n
 *   0x04 --> Use indefinites for hidden monsters ("something")\n
 *   0x08 --> Use indefinites for visible monsters ("a kobold")\n
 *   0x10 --> Pronominalize hidden monsters\n
 *   0x20 --> Pronominalize visible monsters\n
 *   0x40 --> Assume the monster is hidden\n
 *   0x80 --> Assume the monster is visible
 * @note
 * Useful Modes:\n
 *   0x00 --> Full nominative name ("the kobold") or "it"\n
 *   0x04 --> Full nominative name ("the kobold") or "something"\n
 *   0x80 --> Genocide resistance name ("the kobold")\n
 *   0x88 --> Killing name ("a kobold")\n
 *   0x22 --> Possessive, genderized if visible ("his") or "its"\n
 *   0x23 --> Reflexive, genderized if visible ("himself") or "itself"
 * @note (see file monster2.c)
 */
static char *lua_monster_desc @ monster_desc(monster_type *m_ptr, int mode);

$static char *lua_monster_race_desc(int r_idx, int ego){static char buf[200]; monster_race_desc(buf, r_idx, ego); return buf;}
/** @fn monster_race_desc(int r_idx, int ego);
 * @brief Return the monster description for monster with monster index
 * "r_idx" and monster ego "ego".\n
 * @param r_idx Number \n the index of the race in the monster race array
 * @brief Race index
 * @param ego Number \n the index of the ego in the monster ego array
 * @brief Ego index
 * @return String \n The description of the monster race.
 * @note
 * The monster description is made up of the ego name (if any) and monster
 * name, or the unique name.
 * @note (see file w_mnster.c)
 */
static char *lua_monster_race_desc @ monster_race_desc(int r_idx, int ego);

/** @fn monster_race_desc(char *desc, int r_idx, int ego)
 * @brief Return the monster description "desc" for monster with monster index
 * "r_idx" and monster ego "ego".\n
 * @param *desc String
 * @brief Description
 * @param r_idx Number \n the index of the race in the monster race array
 * @brief Race index
 * @param ego Number \n the index of the ego in the monster ego array
 * @brief Ego index
 * @return *desc String \n The description of the monster race.
 * @note
 * The monster description is made up of the ego name (if any) and monster
 * name, or the unique name.
 * @note (see file monster2.c)
 */
extern void monster_race_desc(char *desc, int r_idx, int ego);

/** @fn monster_carry(monster_type *m_ptr, int m_idx, object_type *q_ptr)
 * @brief Allow monster "m_ptr" with monster index "m_idx" to carry object
 * "q_ptr".\n
 * @param *m_ptr monster_type \n the monster
 * @brief Monster
 * @param m_idx Number \n the index of the monster in the monster list
 * @brief Monster index
 * @param *q_ptr object_type \n the object
 * @brief Object
 * @note
 * The monster can only carry the object if there is room for the object in the
 * object list.
 * @note (see file monster2.c)
 */
extern void monster_carry(monster_type *m_ptr, int m_idx, object_type *q_ptr);

/** @fn place_monster_aux(int y, int x, int r_idx, bool slp, bool grp, int status)
 * @brief Attempt to place a monster with monster race index "r_idx" and status
 * "status" at grid "y", "x". The monster may be asleep ("slp") or surrounded
 * by a group of identical monsters ("grp").\n
 * @param y Number \n the y coordinate of the target grid
 * @brief Y-coordinate
 * @param x Number \n the x coordinate of the target grid
 * @brief X-coordinate
 * @param r_idx Number \n the index of the race in the monster race array
 * @brief Race index
 * @param slp Boolean \n TRUE if monster is asleep, otherwise FALSE
 * @brief Asleep?
 * @param grp Boolean \n TRUE if monster appears in a group, otherwise FALSE
 * @brief Group?
 * @param status Number \n the status of the monster from the player's point
 * of view (see MSTATUS_foo flags)
 * @brief Monster status
 * @return Boolean \n TRUE if the monster is placed successfully, otherwise
 * FALSE.
 * @note
 * Note that certain monsters are now marked as requiring "friends".
 * These monsters, if successfully placed, and if the "grp" parameter
 * is TRUE, will be surrounded by a "group" of identical monsters.
 * @note
 * Note that certain monsters are now marked as requiring an "escort",
 * which is a collection of monsters with similar "race" but lower
 * level.
 * @note
 * Some monsters induce a fake "group" flag on their escorts.
 * @note
 * Note the "bizarre" use of non-recursion to prevent annoying output
 * when running a code profiler.
 * @note
 * Note the use of the new "monster allocation table" code to restrict
 * the "get_mon_num()" function to "legal" escort types.
 * @note (see file monster2.c)
 */
extern bool place_monster_aux(int y, int x, int r_idx, bool slp, bool grp, int status);

/** @fn place_monster(int y, int x, bool slp, bool grp)
 * @brief Attempt to place a monster at grid "y", "x". The monster may be
 * asleep ("slp") or surrounded by a group of identical monsters ("grp").\n
 * @param y Number \n the y coordinate of the target grid
 * @brief Y-coordinate
 * @param x Number \n the x coordinate of the target grid
 * @brief X-coordinate
 * @param slp Boolean \n TRUE if monster is asleep, otherwise FALSE
 * @brief Asleep?
 * @param grp Boolean \n TRUE if monster appears in a group, otherwise FALSE
 * @brief Group?
 * @return Boolean \n TRUE if the monster is placed successfully, otherwise
 * FALSE.
 * @note
 * Attempt to find a monster appropriate to the "monster_level"
 * @note (see file monster2.c)
 */
extern bool place_monster(int y, int x, bool slp, bool grp);

/** @fn place_monster_one(int y, int x, int r_idx, int ego, bool slp, int status)
 * @brief Attempt to place a monster with monster race index "r_idx", monster
 * ego "ego" and status "status" at grid "y", "x". The monster may be asleep
 * ("slp").\n
 * @param y Number \n the y coordinate of the target grid
 * @brief Y-coordinate
 * @param x Number \n the x coordinate of the target grid
 * @brief X-coordinate
 * @param r_idx Number \n the index of the race in the monster race array
 * @brief Race index
 * @param ego Number \n the index of the ego in the monster ego array
 * @brief Ego index
 * @param slp Boolean \n TRUE if monster is asleep, otherwise FALSE
 * @brief Asleep?
 * @param status Number \n the status of the monster from the player's point
 * of view (see MSTATUS_foo flags)
 * @brief Monster status
 * @return Number \n The index of the placed monster in the monster list.
 * @note
 * To give the player a sporting chance, any monster that appears in
 * line-of-sight and is extremely dangerous can be marked as
 * "FORCE_SLEEP", which will cause them to be placed with low energy,
 * which often (but not always) lets the player move before they do.
 * @note
 * This routine refuses to place out-of-depth "FORCE_DEPTH" monsters.
 * @note
 * XXX XXX XXX Use special "here" and "dead" flags for unique monsters,
 * remove old "cur_num" and "max_num" fields.
 * @note
 * XXX XXX XXX Actually, do something similar for artifacts, to simplify
 * the "preserve" mode, and to make the "what artifacts" flag more useful.
 * @note
 * This is the only function which may place a monster in the dungeon,
 * except for the savefile loading code.
 * @note (see file monster2.c)
 */
extern s16b place_monster_one(int y, int x, int r_idx, int ego, bool slp, int status);

/** @fn is_friend(monster_type *m_ptr)
 * @brief Return a value to indicate the status of monster "m_ptr".\n
 * @param *m_ptr monster_type \n the monster
 * @brief Monster
 * @return Number \n -1 if monster is an enemy, 0 if it is neutral, and 1 if
 * it is friendly.
 * @note (see file monster3.c)
 */
extern int is_friend(monster_type *m_ptr);

/** @fn is_enemy(monster_type *m_ptr, monster_type *t_ptr)
 * @brief Determine if monster "m_ptr" should attack monster "t_ptr".\n
 * @param *m_ptr monster_type \n the monster
 * @brief Monster
 * @param *t_ptr monster_type \n the target monster
 * @brief Target monster
 * @return Boolean \n TRUE if monster "m_ptr" should attack monster "t_ptr",
 * otherwise FALSE.
 * @note
 * If "m_ptr" is stupid and "r_ptr" is a different type of monster then the
 * function will return TRUE.\n
 * If "m_ptr" is not neutral and "r_ptr" is a breeder, and "r_ptr" is a
 * different type of monster then the function will return TRUE (and vice
 * versa).\n
 * If both monsters are not neutral and one is friendly and the other isn't
 * then the function will return TRUE.
 * @note (see file monster3.c)
 */
extern bool is_enemy(monster_type *m_ptr, monster_type *t_ptr);

/** @fn change_side(monster_type *m_ptr)
 * @brief Change the status of monster "m_ptr" from friendly to unfriendly and
 * vice versa. 
 * @param *m_ptr monster_type \n the monster
 * @brief Monster
 * @return Boolean \n TRUE if the status changed, otherwise FALSE.
 * @note
 * Friends and pets become enemies.\n
 * Neutral monsters become neutral pets and vice versa.\n
 * Companions are unaffected.
 * @note (see file monster3.c)
 */
extern bool change_side(monster_type *m_ptr);

/** @fn find_position(int y, int x, int *yy = 0, int *xx = 0)
 * @brief Find a new grid "yy", "xx" within 6 grids of target grid "y", "x".\n
 * @param y Number \n the y coordinate of the origin grid
 * @brief Origin y-coordinate
 * @param x Number \n the x coordinate of the origin grid
 * @brief Origin x-coordinate
 * @param yy Number \n the y coordinate of the target grid
 * @brief Target y-coordinate
 * @param xx Number \n the x coordinate of the target grid
 * @brief Target x-coordinate
 * @note
 * The new grid must be within line-of-sight of the target grid. A
 * maximum of 5000 attempts is made.
 * @note (see file lua_bind.c)
 */
extern void find_position(int y, int x, int *yy = 0, int *xx = 0);

/** @var summon_specific_level
 * @brief Number
 * @note
 * Force summoned monsters to be at this level.
 */
extern int summon_specific_level;

/** @var summon_kin_type
 * @brief String
 * @note
 * The monster character for those monsters who can summon kin.
 */
extern char summon_kin_type;

/** @fn summon_specific(int y1, int x1, int lev, int type)
 * @brief Place a monster of type "type" near grid "y","x".\n 
 * @param y1 Number \n the y coordinate of the target grid
 * @brief Y-coordinate
 * @param x1 Number \n the x coordinate of the target grid
 * @brief X-coordinate
 * @param lev Number \n the monster level of the summoning monster
 * @brief Summoner level
 * @param type Number \n the type of summoned monster
 * @brief Monster type
 * @return Boolean \n TRUE if a monster was summoned, otherwise FALSE.
 * @note
 * We will attempt to place the monster up to 20 times before giving up.
 * @note
 * Note: SUMMON_UNIQUE and SUMMON_WRAITH (XXX) will summon Unique's\n
 * Note: SUMMON_HI_UNDEAD and SUMMON_HI_DRAGON may summon Unique's\n
 * Note: None of the other summon codes will ever summon Unique's.
 * @note
 * This function has been changed.  We now take the "monster level"
 * of the summoning monster as a parameter, and use that, along with
 * the current dungeon level, to help determine the level of the
 * desired monster.  Note that this is an upper bound, and also
 * tends to "prefer" monsters of that level.  Currently, we use
 * the average of the dungeon and monster levels, and then add
 * five to allow slight increases in monster power.
 * @note
 * Note that we use the new "monster allocation table" creation code
 * to restrict the "get_mon_num()" function to the set of "legal"
 * monsters, making this function much faster and more reliable.
 * @note
 * Note that this function may not succeed, though this is very rare.
 * @note (see file monster2.c)
 */
extern bool summon_specific(int y1, int x1, int lev, int type);

/** @fn summon_specific_friendly(int y1, int x1, int lev, int type, bool Group_ok)
 * @brief Place a friendly monster of type "type" near grid "y","x". The
 * monster may be surrounded by a group of identical monsters ("Group_ok").\n 
 * @param y1 Number \n the y coordinate of the target grid
 * @brief Y-coordinate
 * @param x1 Number \n the x coordinate of the target grid
 * @brief X-coordinate
 * @param lev Number \n the monster level of the summoning monster
 * @brief Summoner level
 * @param type Number \n the type of summoned monster
 * @brief Monster type
 * @param Group_ok Boolean \n TRUE if monster appears in a group, otherwise
 * FALSE
 * @brief Group?
 * @return Boolean \n TRUE if a monster was summoned, otherwise FALSE.
 * @note (see file monster2.c)
 */
extern bool summon_specific_friendly(int y1, int x1, int lev, int type, bool Group_ok);

/** @fn summon_monster_aux(int y, int x, int lev, bool friend, char *fct);
 * @brief Place a monster near grid "y","x".\n 
 * @param y Number \n the y coordinate of the target grid
 * @brief Y-coordinate
 * @param x Number \n the x coordinate of the target grid
 * @brief X-coordinate
 * @param lev Number \n the monster level of the summoning monster
 * @brief Summoner level
 * @param friend Boolean \n TRUE if friendly monsters are to be summoned,
 * otherwise FALSE
 * @brief Friendly?
 * @param *fct String \n the function which determines which type of monster
 * will be summoned
 * @brief Monster type function
 * @return Boolean \n TRUE if a monster was summoned, otherwise FALSE.
 * @note (see file w_mnster.c)
 */
extern bool lua_summon_monster @ summon_monster_aux(int y, int x, int lev, bool friend, char *fct);

/** @fn can_create_companion()
 * @brief Determine if a companion can be created.
 * @return Boolean \n TRUE if a companion can be created, otherwise FALSE.
 * @note
 * The companions are counted. If this is less than the number allowed by
 * the player monster lore skill, the function returns TRUE, otherwise the
 * function returns FALSE.
 * @note (see file monster3.c)
 */
extern bool can_create_companion();

/** @fn monster_set_level(int m_idx, int level)
 * @brief Set a new level for monster with monster index "m_idx".\n
 * @param m_idx Number \n the index of the monster in the monster list
 * @brief Monster index
 * @param level Number \n the new level of the monster
 * @brief Monster level
 * @note
 * The new level can not exceed 150. If the new level is higher than the
 * monster level, the monster experience value is recalculated.
 * @note (see file monster2.c)
 */
extern void monster_set_level(int m_idx, int level);

/** @name Summon types
 * @note Legal restrictions for "summon_specific()"
 */
/** @def SUMMON_ANT
 * @note Summon giant ant (a) excluding uniques.
 */
#define SUMMON_ANT                  11

/** @def SUMMON_SPIDER
 * @note Summon spider/scorpion/tick (S) excluding uniques.
 */
#define SUMMON_SPIDER               12

/** @def SUMMON_HOUND
 * @note Summon canine (C) or zephyr hound (Z) excluding uniques.
 */
#define SUMMON_HOUND                13

/** @def SUMMON_HYDRA
 * @note Summon multi-headed hydra (M) excluding uniques.
 */
#define SUMMON_HYDRA                14

/** @def SUMMON_ANGEL
 * @note Summon angelic being (A) excluding uniques.
 */
#define SUMMON_ANGEL                15

/** @def SUMMON_DEMON
 * @note Summon demon (RF3_DEMON) excluding uniques.
 */
#define SUMMON_DEMON                16

/** @def SUMMON_UNDEAD
 * @note Summon undead (RF3_UNDEAD) excluding uniques.
 */
#define SUMMON_UNDEAD               17

/** @def SUMMON_DRAGON
 * @note Summon dragon (RF3_DRAGON) excluding uniques.
 */
#define SUMMON_DRAGON               18

/** @def SUMMON_HI_UNDEAD
 * @note Summon lich (L) or vampire (V) or wight/wraith (W) including uniques.
 */
#define SUMMON_HI_UNDEAD            21

/** @def SUMMON_HI_DRAGON
 * @note Summon ancient dragon (D) including uniques.
 */
#define SUMMON_HI_DRAGON            22

/** @def SUMMON_WRAITH
 * @note Summon wight/wraith (W) including uniques.
 */
#define SUMMON_WRAITH               31

/** @def SUMMON_UNIQUE
 * @note Summon unique (RF1_UNIQUE).
 */
#define SUMMON_UNIQUE               32

/** @def SUMMON_BIZARRE1
 * @note Summon mold (m) excluding uniques.
 */
#define SUMMON_BIZARRE1             33

/** @def SUMMON_BIZARRE2
 * @note Summon giant bat (b) excluding uniques.
 */
#define SUMMON_BIZARRE2             34

/** @def SUMMON_BIZARRE3
 * @note Summon quylthulg (Q) excluding uniques.
 */
#define SUMMON_BIZARRE3             35

/** @def SUMMON_BIZARRE4
 * @note Summon vortex (v) excluding uniques.
 */
#define SUMMON_BIZARRE4             36

/** @def SUMMON_BIZARRE5
 * @note Summon creeping coins ($) excluding uniques.
 */
#define SUMMON_BIZARRE5             37

/** @def SUMMON_BIZARRE6
 * @note Summon mimic (!?=$|) excluding uniques.
 */
#define SUMMON_BIZARRE6             38

/** @def SUMMON_HI_DEMON
 * @note Summon demon (RF3_DEMON) and major demon (U) excluding uniques.
 */
#define SUMMON_HI_DEMON             39

/** @def SUMMON_KIN
 * @note Summon monster of the same character type excluding uniques.
 */
#define SUMMON_KIN                  40

/** @def SUMMON_DAWN
 * @note Summon monster with "the Dawn" in the name excluding uniques.
 */
#define SUMMON_DAWN                 41

/** @def SUMMON_ANIMAL
 * @note Summon animal (RF3_ANIMAL) excluding uniques.
 */
#define SUMMON_ANIMAL               42

/** @def SUMMON_ANIMAL_RANGER
 * @note Summon animal (RF3_ANIMAL) and giant ant, giant bat, centipede,
 * feline,giant louse, quadruped, rodent, worm or worm mass, bird, canine,
 * insect, snake, killer beetle, multi-headed hydra, reptile/amphibian,
 * spider/scorpion/tick (abcflqrwBCIJKMRS) and not dragon (RF3_DRAGON) and not
 * evil (RF3_EVIL) and not undead (RF3_UNDEAD) and not demon (RF3_DEMON) and
 * not inate/breath and not normal spells and not special spells excluding
 * uniques.
 */
#define SUMMON_ANIMAL_RANGER        43

/** @def SUMMON_HI_UNDEAD_NO_UNIQUES
 * @note Summon lich (L) or vampire (V) or wight/wraith (W) excluding uniques.
 */
#define SUMMON_HI_UNDEAD_NO_UNIQUES 44

/** @def SUMMON_HI_DRAGON_NO_UNIQUES
 * @note Summon ancient dragon (D) excluding uniques.
 */
#define SUMMON_HI_DRAGON_NO_UNIQUES 45

/** @def SUMMON_NO_UNIQUES
 * @note Summon non-uniques (not RF1_UNIQUE).
 */
#define SUMMON_NO_UNIQUES           46

/** @def SUMMON_PHANTOM
 * @note Summon monster with "Phantom" in the name excluding uniques.
 */
#define SUMMON_PHANTOM              47

/** @def SUMMON_ELEMENTAL
 * @note Summon monster with "lemental" in the name excluding uniques.
 */
#define SUMMON_ELEMENTAL            48

/** @def SUMMON_THUNDERLORD
 * @note Summon thunderlords (RF3_THUNDERLORD) including uniques.
 */
#define SUMMON_THUNDERLORD          49

/** @def SUMMON_BLUE_HORROR
 * @note Summon monster with "lue horror" in the name excluding uniques.
 */
#define SUMMON_BLUE_HORROR          50

/** @def SUMMON_BUG
 * @note Summon monster with "Software bug" in the name excluding uniques.
 */
#define SUMMON_BUG                  51

/** @def SUMMON_RNG
 * @note Summon monster with "Random Number Generator" in the name excluding
 * uniques.
 */
#define SUMMON_RNG                  52

/** @def SUMMON_MINE
 * @note Summon mines (RF1_NEVER_MOVE) including uniques.
 */
#define SUMMON_MINE                 53

/** @def SUMMON_HUMAN
 * @note Summon (p) excluding uniques.
 */
#define SUMMON_HUMAN                54

/** @def SUMMON_SHADOWS
 * @note Summon ghost (G) excluding uniques.
 */
#define SUMMON_SHADOWS              55

/** @def SUMMON_GHOST
 * @note Summon ghost (G) including uniques.
 */
#define SUMMON_GHOST                56

/** @def SUMMON_QUYLTHULG
 * @note Summon (Q) excluding uniques.
 */
#define SUMMON_QUYLTHULG            57

/** @def SUMMON_LUA
 * @note Summon monsters according to a Lua script.
 */
#define SUMMON_LUA                  58
/** @} */

/** @fn do_control_reconnect()
 * @brief Find the controlled monster and reconnect to it.
 * @return Boolean \n TRUE if there is a controlled monster, otherwise FALSE.
 * @note
 * The monster list is scanned for a monster with MFLAG_CONTROL. If it is
 * found, the function returns TRUE.
 * @note (see file monster3.c)
 */
extern bool do_control_reconnect();

/* monster thing */
/** @var m_max
 * @brief Number
 * @note The number of monsters currently in the monster list.
 */
extern s16b m_max;
